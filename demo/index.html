<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>

    <link rel="stylesheet" href="./style/normalize.css" />
    <link rel="stylesheet" href="./style/corgicoding.theme.min.css" />
    <link rel="stylesheet" href="./style/github.css" />
  </head>
  <body>
    <div class="c-html-render" data-v-10d9911b=""><div id="c-show-area" data-v-10d9911b=""><h1>不可或缺的 Code Review 环节！如何实施？</h1>
      <p>众所周知，Code Review 是开发过程中一个非常重要的环节，但是很多公司或者团队是没有这个环节，或者说不重视这个环节，今天我们结合实际情况来谈谈 <a href="https://github.com/charleschan1998">Code Review</a> 的价值以及如何实施。</p>
      <h2>Code Review 的价值</h2>
      <p>许多团队没有 <code>Code Review</code> 环节，或者因为追求项目的快速上线，认为 CR 浪费时间；或者团队成员缺少 CR 观念，认为 CR 的价值并不大。所以想要在团队内推动 Code Review 的实施，最最重要的一点便是增强团队成员对 Code Review 环节的认同感。</p>
      <p>Code Review 环节，它更依赖于团队成员的主观能动性，只有团队成员对其认可，他们才会积极主动参与这个环节，CR 的价值才能最大化体现。如果团队成员不认可 CR，即使强制设置了 CR 流程，也是形同虚设，反而可能阻碍正常开发流程的效率。那么如何让团队成员认可 CR 环节呢，自然是让他们意识到 CR 的价值，然后就会 ... 真香！</p>
      <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5e284a8e87e4340b5f20e9c88fb2777~tplv-k3u1fbpfcp-zoom-1.image?imageslim" alt="img"></p>
      <h3>提升团队代码质量</h3>
      <p>随着团队规模的扩大和项目的迭代升级，团队之间的信息透明度会越来越低，项目的可维护性也会越来越差，可能引发一系列问题：</p>
      <ul>
      <li>已有的 utils 方法，重复造轮子</li>
      <li>代码过于复杂，缺少必要注释，后人难以维护</li>
      <li>目录结构五花八门，杂乱不堪</li>
      </ul>
      <pre class="hljs"><code>    <span class="hljs-keyword">let</span> a = <span class="hljs-string">"true"</span>;
          <span class="hljs-built_in">this</span>.flag = a;
      
          <span class="hljs-comment">// rewrite</span>
          <span class="hljs-built_in">this</span>.flag = <span class="hljs-string">"true"</span>;
      </code></pre>
      <hr>
      <p>合理的 CR 环节可以有效的把控每次提交的代码质量，不至于让项目的可维护性随着版本迭代和时间推移变得太差，这也是 CR 的首要目的。 <strong>CR 环节并不会降低开发效率</strong> ，就一次代码提交来说，也许部分人认为 CR 可能花费了时间，但是有效的 CR 给后人扩展和维护所节省的时间远超于此。</p>
      <h3>团队技术交流</h3>
      <p>Reviewer 和 Reviewee 在参与 CR 的过程中，都是可以收获到许多知识，进行技术交流的。</p>
      <ul>
      <li>有利于帮助新人快速成长，团队有新人加入时，往往需要导师带领一段时间，通过 CR 环节，可以使导师最直接了解到新人开发过程中所遇到的问题，做出相应的指导</li>
      <li>通过 CR 环节，团队成员可以了解他人的业务，而不局限于自己所负责的业务范围。项目发现问题时，可以迅速定位到相关业务的负责人进行修改，同时若有团队成员离职，也可以减少业务一人负责所带来的后期维护问难的问题。</li>
      <li>学习他人的优秀代码。通过 CR 环节，可以迅速接触到团队成员在项目中解决某些问题的优秀代码，或者使用一些你所未接触过的 API 等。</li>
      </ul>
      <h3>保证项目的统一规范</h3>
      <p>既然要进行 CR，首先要对项目的规范制定要求，包括编码风格规范、目录结构规范、业务规范等。一方面，同意的项目规范才能保证项目的代码质量，提高项目的质量和可维护性；另一方面，在大家熟悉了统一规范之后，能够提升 CR 的效率，节省时间。</p>
      <h2>Code Review 的实践</h2>
      <p>关于 Code Review 的实践，要考虑的包括 CR 所花费的时间、CR 的形式、何时进行 CR 等等。</p>
      <h3>预留 CR 的时间</h3>
      <p>首先不得不承认，CR 环节是要耗费一定时间的，所以在项目排期中，不仅要考虑开发、联调、提测、改 bug 等时间，还要预留出 CR 的时间。包括担任 Reviewer 和 Reviewee 角色的时间都要考虑。另外如果遇到需求比较复杂，为了避免因为 CR 过程导致代码需要大量修改，最好提前和团队成员沟通好需求的设计和结果思路。</p>
      <h3>CR 的形式</h3>
      <p>我所见过的 CR 大多有两种形式。一种是设立一个特定的时间，例如周会，团队成员一起对之前的 MR 进行 CR；另一种是对每一个 MR 都进行 CR。</p>
      <p>我个人更加推荐后者。第一种定期 CR，如果 MR 的数量太多，不太可能对所有的 MR 进行 CR，如果 CR 之后再对之前的 MR 进行修改的成本太大，而且一次性太多的 CR 会打击团队成员的积极性。第二种 CR 就相对来说轻松一些，可以考虑轮流对 MR 进行 CR。</p>
      <h3>CR 的时机</h3>
      <p>CR 的环节应该设立在提测环节附近。因为 CR 后如果优化代码虽然理论上只是代码优化，但可能会不小心动到业务逻辑，如果是提测之后再进行 CR 很有可能会影响到已经测试过的功能点。</p>
      <p>当然也可以分情况，如果遇到比较紧急的需求或者 bug 修复，那么也可以先提测，后续再做相应的 CR。</p>
      <h2>对团队成员的要求</h2>
      <p>前面已经提到，要增强团队成员对 CR 环节的认同感。作为 CR 环节的参与者，还应该根据自己团队的特点，对团队成员做出相应要求。</p>
      <h3>Reviewer</h3>
      <ol>
      <li>指明 review 类型。reviewer 给出相应的代码评论时，建议指明评论的类型，可以在评论前用 [] 做出标识，例如：
      <ol>
      <li><code>[request]xxxxxx</code>              此条评论的代码必须修改才能予以通过</li>
      <li><code>[advise]xxxxxx</code>                此条评论的代码建议修改，但不修改也可以通过</li>
      <li><code>[question]xxxxxx</code>            此条评论的代码有疑问，需要 reviewee 进一步解释</li>
      </ol>
      </li>
      <li>讲明该评论的原因。在对代码做出评论时，应当解释清楚原因，如果自己有现成的更好的解决思路，应当把相应的解决思路也写上去，节省 reviewee 的修改时间</li>
      <li>平等友善的评论。评论者在 review 的过程中，目的是提升项目代码质量，而不是抨击别人，质疑别人的能力，应当保持平等友善的语气。</li>
      <li>享受 Code Review。只有积极的参与 CR，把 CR 作为一种享受，才能将 CR 的价值最大化体现。</li>
      </ol>
      <h3>Reviewee</h3>
      <ol>
      <li>注重注释。对于复杂代码写明相应注释，在进行 commit 时也应简明地写清楚北京，帮助 reviewer 理解，提高 review 效率。</li>
      <li>保持乐观的心态接受别人 review。团队成员的 review 不是对你的批判，而是帮助你的提升，所以要尊重别人 review，如果 review 你感觉不正确，可以在下面提出疑问，进一步解释。</li>
      <li>完成相应的 review 修改应当在下面及时进行回复，保持信息同步。</li>
      </ol>
      </div></div>
      <div id="c-show-area" data-v-10d9911b="">
        <h1>如何制作一个组件？论组件化思想</h1>
        <h2>写在前面</h2>
        <p>
          先进的 web 开发通过前后端分离的技术拆分为了 web 后端开发与 web
          前端开发，值得指出的是，web
          前端开发早已不是传统意义上的开发模式了，转而变成了
          <strong>web 客户端开发，</strong>
          有过客户端开发经验的同学应该知道这两者的区别，客户端开发关注的是：
        </p>
        <ul>
          <li>应用的生命周期</li>
          <li>组件化</li>
          <li>开发模式与打包方法</li>
        </ul>
        <p>
          组件化是客户端开发最重要的内容，设计一套复用度高、扩展性好的组件系统，可以
          <strong>显著提高开发效率，</strong> 并且可以
          <strong>减少后期的维护成本。</strong>
        </p>
        <h2>一个笔记组件的设计案例</h2>
        <p>
          <img
            src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3294861d0a60486da7cb903cc06e9624~tplv-k3u1fbpfcp-zoom-1.image"
            alt="img"
          />
        </p>
        <p>
          就一我们正在使用的笔记 app
          为例，上图展示的笔记的阅读与书写区域，如何将这个区域抽象为一个组件呢？让我们一步一步来分析。
        </p>
        <h3>最简 API</h3>
        <p>
          我们为该组件取个名字（取名很重要），就叫 Note
          吧。不管是在阅读状态还是编辑状态，该组件都要展示笔记的内容，因为笔记对象应该通过组件的接口传入进来，因为我们为该组件设计第一个
          API：
        </p>
        <table>
          <thead>
            <tr>
              <th>属性</th>
              <th>说明</th>
              <th>类型</th>
              <th>是否必填</th>
              <th>默认值</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>data</td>
              <td>笔记对象数据</td>
              <td>object</td>
              <td>是</td>
              <td>null</td>
            </tr>
          </tbody>
        </table>
        <p>接下来我们简单使用一下这个组件：</p>
        <pre class="hljs"><code><span class="hljs-keyword">const</span> note = {
  <span class="hljs-attr">title</span>: <span class="hljs-string">'如何制作一个组件.md'</span>,
  <span class="hljs-attr">content</span>: <span class="hljs-string">''</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Note</span> <span class="hljs-attr">data</span>=<span class="hljs-string">{note}</span> /&gt;</span></span>
}
</code></pre>
        <p>
          这样，一个最简 API
          的笔记组件就搞定了，它的接口非常简单，只需要提供一个 data
          属性，就可以展示出笔记内容，并且可以点击编辑进入书写状态。
        </p>
        <p>
          一般而言，如果没有更多的需求的话，我们的笔记组件设计到这里就可以了。
          <strong
            >在设计组件时，务必遵循最小化原则，即尽可能少抛出接口。</strong
          >
          因为使用组件的用户可能很多，一旦组件作者不小心跑出了一个不合理的接口，以后想要修改就几乎不可能了（只能通过标记果实的方法提醒用户，但这种做法往往是无奈之举）。
        </p>
        <h3>满足数据获取的多种情况</h3>
        <p>
          现在，组件的使用者已经可以通过很简洁的 API
          使用这个笔记组件了，但是新的问题来了：
          <strong
            >有的组件使用者只拿到了笔记的 id，想要通过直接传入 id
            的方式使用组件。</strong
          >
        </p>
        <p>
          此时，作为组件作者，我们评估了这个需求是合理的，于是我们扩展了笔记组件的
          API：
        </p>
        <table>
          <thead>
            <tr>
              <th>属性</th>
              <th>说明</th>
              <th>类型</th>
              <th>是否必填</th>
              <th>默认值</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>data</td>
              <td>笔记对象数据</td>
              <td>object</td>
              <td>否</td>
              <td>null</td>
            </tr>
            <tr>
              <td>dataId</td>
              <td>笔记对象id</td>
              <td>string</td>
              <td>否</td>
              <td>null</td>
            </tr>
          </tbody>
        </table>
        <p>现在可以通过传入 id 的方式来使用组件了：</p>
        <pre
          class="hljs"
        ><code><span class="hljs-keyword">const</span> noteId = <span class="hljs-string">'123'</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Note</span> <span class="hljs-attr">dataId</span>=<span class="hljs-string">{noteId}</span> /&gt;</span></span>
}
</code></pre>
        <blockquote>
          <p>
            请注意，API
            中的两个属性都是非必填的，因为不知道用户会传入哪个属性，为了程序的严谨性，组件内部应当校验两个参数都不传的情况，并通过抛出错误告诉调用者。
          </p>
        </blockquote>
        <p>
          这是组件设计的一个技巧，通过支持多种数据源使得调用更加简单。但是这种设计也有其弊端所在，如果这种兼容性的扩展过多会使得组件的内部逻辑变得复杂，也会使得
          API 变得难于理解，因此，
          <strong>对于兼容性的 API 扩展要谨慎，不可过量。</strong>
        </p>
        <h3>兼容不同模式</h3>
        <p>
          组件的使用一如既往的优雅、简单，但是现在又有用户提出新的需求：
          <strong
            >因为该组件是支持阅读与编辑两种模式，在使用时，对于他人的笔记是不可编辑的，能否在指定场景下只支持一种阅读模式？</strong
          >
        </p>
        <p>
          笔记组件由于内部支持了两种模式，既支持阅读，又支持编辑，因此调用者只想使用一种模式也是合理的，于是我们继续扩展组件
          API：
        </p>
        <table>
          <thead>
            <tr>
              <th>属性</th>
              <th>说明</th>
              <th>类型</th>
              <th>是否必填</th>
              <th>默认值</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>mode</td>
              <td>模式，数组的第一项作为初始模式，该参数不可为空数组</td>
              <td>array</td>
              <td>否</td>
              <td><code>['write', 'read']</code></td>
            </tr>
          </tbody>
        </table>
        <p>现在对于只想使用阅读模式的用户，可以这么调用：</p>
        <pre
          class="hljs"
        ><code><span class="hljs-keyword">const</span> note = {}
<span class="hljs-keyword">const</span> mode = [<span class="hljs-string">'read'</span>]

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>{
	<span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Note</span> <span class="hljs-attr">data</span>=<span class="hljs-string">{note}</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">{mode}</span> /&gt;</span></span>
}
</code></pre>
        <p>
          在设计api时，我们在满足需求的前提下，支持了更多情况。首先，使用者也可能只使用编辑模式，因为mode参数是支持随意组合各种模式的，因此这种情况也能满足。另外，如果组件以后扩展了更多模式，该api仍然能满足需求，只需要为mode数组增加更多的模式项即可。
        </p>
        <p>
          这里有一个更佳的设计是，当使用多个模式时，确定哪个模式作为初始模式也是有必要的，因此，将mode数组的第一项作为多模式下的初始模式，既满足了需求，又达到了api设计最小化的原则。
        </p>
        <p>
          现在，我们对用户的需求进行了扩展，不仅支持只使用阅读模式，还支持各种模式任意组合和初始模式，但是这还不够，组件的设计者应当针对需求想到更长远的情况，针对这个例子，我们还可以为组件扩展一个模式改变的事件，让调用者可以捕捉到笔记组件从阅读
          -&gt; 编辑或编辑 -&gt;
          阅读（随着模式的扩展，这种组合会更多）切换的时机：
        </p>
        <table>
          <thead>
            <tr>
              <th>事件</th>
              <th>说明</th>
              <th>回调参数</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>modeChange</td>
              <td>模式切换时触发</td>
              <td>
                (from: string, to: string)
                from表示切换前的模式，to表示切换后的模式
              </td>
            </tr>
          </tbody>
        </table>
        <p>调用者可能在捕捉到模式切换事件时，做一些特定的工作：</p>
        <pre
          class="hljs"
        ><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleModeChange</span>(<span class="hljs-params"><span class="hljs-keyword">from</span>, to</span>) </span>{
  <span class="hljs-comment">// ...</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Note</span> <span class="hljs-attr">onModeChange</span>=<span class="hljs-string">{handleModeChange}</span>  /&gt;</span></span>
}
</code></pre>
        <h3>更多的支持</h3>
        <p>
          在编辑器中编辑笔记时 html 或 markdown 类型的，
          笔记组件支持将组件导出为一个 PDF
          文档。因此，设计时我们可以将组件的一些能力抽象为 API，再次扩展组件的
          API：
        </p>
        <table>
          <thead>
            <tr>
              <th>方法</th>
              <th>说明</th>
              <th>参数</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>exportPDF</td>
              <td>导出笔记为PDF文件</td>
              <td>-</td>
            </tr>
            <tr>
              <td>toggleFullscreen</td>
              <td>切换全屏显示</td>
              <td>(value: boolean) 是否全屏展示</td>
            </tr>
          </tbody>
        </table>
        <p>
          组件设计时，我们可以将可预见范围内的组件能力设计为
          API，需要注意的是，方法的参数与返回值也是 API 的一部分，应当谨慎设计。
        </p>
        <p>
          除了扩展组件的能力外，我们还可以扩展组件的视图。注意到阅读按钮右侧的工具栏了吗？我们假设这部分的视图不属于笔记组件，是通过
          API 扩展而渲染出来的，这就是组件的 <strong>子视图设计，</strong> 在
          web 前端的组件化中，称为
          <strong>插槽。</strong> 我们可以为笔记组件扩展一个工具栏的插槽：
        </p>
        <table>
          <thead>
            <tr>
              <th>插槽</th>
              <th>说明</th>
              <th>参数</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>toolbar</td>
              <td>工具栏子视图</td>
              <td>{ data }</td>
            </tr>
          </tbody>
        </table>
        <p>当调用者想要扩展笔记组件的工具栏时，可以这么使用：</p>
        <pre
          class="hljs"
        ><code><span class="hljs-keyword">const</span> note = {}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Note</span> <span class="hljs-attr">data</span>=<span class="hljs-string">{note}</span>&gt;</span>
  	<span class="hljs-tag">&lt;<span class="hljs-name">MyToolbar</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">Note</span>&gt;</span></span>
}
</code></pre>
        <p>这样，调用者就可以根据自己的需求，在工具栏渲染自己想要的内容。</p>
        <h2>组件设计四要素</h2>
        <p>
          上述案例讲述了组件设计的整个流程，通过分析用户的需求（或未来可能出现的需求），一步一步地设计出了一个复用度高、扩展性好的组件。如果你是一个组件设计的新手，你应该如何去思考、去设计一个优良的组件呢？
        </p>
        <h3>先设计，后实现</h3>
        <p>
          我们通篇在讨论组件的设计，但是实际操作时，很多朋友会通过边实现边设计的方式来完成一个组件的制作，这是不合理的，因为自身能力与眼界的限制，实现可能会干扰你的设计，对于以下两个景点矛盾，希望读者选择后者，以追求合理性为重。
        </p>
        <blockquote>
          <ol>
            <li>这样实现比较方便，不如将这个参数抛出让用户传进来吧！</li>
            <li>
              这样设计比较合理，虽然实现难度可能会比较高，但我可以通过文档学习、求问他人的方式来实现它，或者直接让他人来实现。
            </li>
          </ol>
        </blockquote>
        <p>
          <strong>提出问题比解决问题更难。</strong> 设计难于实现，你应当花 70%
          的时间来设计而不是用来实现，有的设计者甚至不参与实现，设计者与实现者的身份也是随时转换的，善于思考的实现者本身就是设计者。
        </p>
        <h3>组件设计四要素</h3>
        <ul>
          <li>属性</li>
          <li>方法</li>
          <li>事件</li>
          <li>子视图（插槽）</li>
        </ul>
        <p>
          上述的案例基本涵盖了这四个要素，这四要素共同组成了组件的api。需要注意的，除了基本的四要素外，我们还需要注意这些也是组件api的一部分：
        </p>
        <ul>
          <li>属性的类型、是否必填、默认值（属性类型确定后不再变化）</li>
          <li>方法的参数、返回值（需要考虑变化的情况）</li>
          <li>事件回调函数的参数</li>
          <li>插槽可获取到的局部参数</li>
        </ul>
        <p>
          在设计时，应当小心谨慎面对每一个 API
          的要素，哪一个环节出现了设计缺陷，对于调用者都是如鲠在喉。
        </p>
        <h2>终极思考：面向对象</h2>
        <p>
          尽管我们通过一系列的理论讲述了组件设计的方法，但是对于初学者来说，仍然难以设计出一个优良的组件，设计一个优良的组件需要大量的经验，初学者往往考虑不全面，或因对需求的不了解，无法预知未来的变化。
        </p>
        <p>
          尽管如此，初学者仍要耐心学习组件的设计，不积硅步无以至千里，经过一段时间的积累，我总结了一个设计组件的终极思维，将
          <strong>面向对象</strong> 的思想用于组件设计，将会事半功倍。
        </p>
        <p>
          在开发领域，学会思考比埋头干活重要。我们将这个理论用于组件设计中，如何通过面向对象的思维来设计一个组件呢？
        </p>
        <p>
          虽然我们强调使用面向对象的思维来设计组件，但仿佛面向对象思维比组件设计更高深，我们当然不会推荐大家用更加晦涩的理论来指导组件的设计，这里，我们将面向对象拟人化，提取出一个
          <strong>自然世界联想法</strong> 的思考方法。
        </p>
        <p>下面我们就用这个方法来设计一个「快递小哥」组件：</p>
        <p>
          首先快递小哥有他的基本信息，这是该组件的
          <strong>属性</strong>
          ，基本信息包含他的任职单位、工作年限、姓名、联系方式等。此外，快递小哥有一些特定的行为，例如送快递、接受包裹等，我们可以将这部分抽取为组件的方法，比如我们调用快递小哥的接收包裹方法，该方法有两个参数，第一个参数是我要寄的东西即包裹，第二个参数是快递单，描述了寄送相关信息。除了基本信息和一些行为外，快递小哥组件还有一些特定的事件，当我们的包裹到了时，他会打电话给我们，这里，组件抛出一个
          <strong>快递到达</strong>
          的事件，时间的参数是快递单和包裹，快递单描述了包裹的送达信息，包裹是快递单中描述的接收人的东西。最后，快递小哥组件有没有子视图呢？有，快递小哥组件除了被我们普通用户调用外，还会被快递公司所调用，不同的快递公司会以不同的方式来包装快递小哥（例如通过不同服饰不同
          logo
          等），因此，快递公司在调用该组件时，会将快递小哥的服装传入一个名为
          <strong>装束</strong> 的子视图中，这样不同的快递小哥就有不同的装束了。
        </p>
        <p>
          你可以使用自然世界联想法来思考一切关于面向对象与组件化相关的问题，只要计算机世界仍然是<strong>人</strong>构建的，我们就仍然可以按照自然世界的规则来感知计算机世界。
        </p>
        <blockquote>
          <p>
            二进制世界从来不是冰冷、无情的，每一个二进制串都融入了编码人的思维模式、价值观。
          </p>
        </blockquote>
        <h2>最后</h2>
        <p>
          重新回到开篇的问题，为什么说当今的web前端开发已变成web客户端开发呢？因为组件化是所有客户端开发的核心概念，只要这个端大部分的时间在做组件抽象的工作，我们就可以认为自己在从事客户端开发。
        </p>
        <p>
          最后，组件化不是银弹，不能为你解决任何实际问题，它只是一种思维方式。
        </p>
      </div>
    </div>
  </body>
</html>
